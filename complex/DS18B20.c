#include "STC51.h"
#include "intrins.h" 
#include "delay.h"
#include "DS18B20.h"
																			   
void DS_18B20_init()		      //DS18B20 初始化
{	
		ds=1;			              //1.  先将数据线置高电平1;
		delayus(1);		          //2.  延时（该时间要求的不是很严格，但是尽可能的短一点）;
		ds=0;						        //3.  数据线拉到低电平0;
		delayus(450);				    //4.  延时490微秒（该时间的时间范围可以从480到960微秒);
		ds=1;						        //5.  先将数据线置高电平1;
		delayus(300);				    //6.  延时等待（如果初始化成功则在15到60毫秒时间之内产生一个由DS18B20所返回的低电平0。
													  //    直接跳过下面一些判断  延时代替  注：延时最少要150微秒  最大不能超过 500微秒                       
}
unsigned char DS_18B20_du()				  //读取温度函数   一位一位的取
{
		 unsigned char du;
		 ds=0;						    // 1. 将数据线拉低“0”。
		 _nop_();					  
		 _nop_();					    // 2. 延时确定的时间为2(小于15)微秒。
		 _nop_();
		 _nop_();
		 ds=1;						    // 3. 将数据线拉高“1”，同时端口应为输入状态。
		 _nop_();
		 _nop_();
		 _nop_();					    // 4. 延时确定的时间为4(小于15)微秒。
		 _nop_();
		 du=ds;						    // 5. 读数据线的状态得到1个状态位，并进行数据处理。
		 delayus(30);	              //    每次读完数据   必须要延时30~60微秒  再把中线拉高    否则读回数据是不对
		 ds=1;						    // 6. 总线拉高
		 delayus(2);				  // 7. 延时等待稳定
		 return du;					  // 8. 返回值  等待下次再读取
}
unsigned char DS_18B20_zijie()	// 读取到的值写成一个字节函数
{
		unsigned char ii,jj,kk;
		for(ii=0;ii<8;ii++)			    //八位  一个字节有八位
		{
				jj=DS_18B20_du();		   //先把读取的一位值送给变量存起来
				kk=(jj<<7)|(kk>>1);		 //	再把刚才读到哪个位向左移7位送给另一个变量存起来  
		}							      
		return kk;					   // 一次只能读一位，读完8次 返回值  等待下次读
	/********************************************************************************************
	比如：假设读回第一个值是‘1’  jj=0000 0001 向左移7位变成  jj=1000 0000
	运算：kk默认的值是 0000 0000，kk向右移一位，kk=0000 0000，  kk=(jj<<7)|(kk>>1)  结果等于 kk=1000 0000 
	到第二次读回的值是‘0’，jj=0000 0000 向左移7位变成  jj=0000 0000  。
	运算：kk的值是 1000 0000 , kk向右移一位 ， kk=0100 0000， kk=(jj<<7)|(kk>>1)    结果等于 kk=0100 0000 
	***********************************************************************************************/
}
void DS_18B20_ling(unsigned char ling)
{
		unsigned char ii;
		for(ii=0;ii<8;ii++)
		{
				 ds=0;					   // 1. 数据线先置低电平0。
				 _nop_();				   // 2. 延时确定的时间为2(小于15)微秒。
				 _nop_();
				 _nop_();
				 _nop_();
				 ds=ling&0x01; 			   // 3. 按从低位到高位的顺序发送字节（一次只发送一位）。
				 delayus(30);	     // 4. 每次送完数据和指令，必须要延时40~90微秒，再拉总线，否则写的指令是不对，对AT89S52单片机这里要掩延时5就行。对于STC单片机 这里要蜒邮30
				 ds=1;					   // 5. 将数据线拉到高电平
				 _nop_();
				 _nop_();				   // 6. 延时确定的时间为2(小于15)微秒。
				 _nop_();				   
				 ling=ling>>1;			   // 7. 把已经送忘那位向右移除去
		}
		delayus(10);				   // 8. 送完8位后延时灯稳定
}
unsigned int DS_18B20_quwen()			   //温度采集，运算
{
		unsigned char temH,temL;
		unsigned int wen;
		DS_18B20_init();			   // 1. 温度初始化
		DS_18B20_ling(0xcc);		   // 2. 跳过读序号列号的操作
		DS_18B20_ling(0x44);		   // 3. 启动温度转换
		delayus(100);				   // 4. 延时等待一会
		DS_18B20_init();			   // 5. 温度再次初始化
		DS_18B20_ling(0xcc);		   // 6. 再跳过读序号列号的操作
		DS_18B20_ling(0xbe);		   // 7. 读取温度寄存器等（共可读9个寄存器） 前两个就是温度  
		temL=DS_18B20_zijie();		   // 8. 取地位值存起来
		temH=DS_18B20_zijie();		   // 9. 取高位值存起来
		wen=temH;					   // 10.把高位值赋给16位的变量存起来
		wen=wen<<8;				   // 11.再把高位向左移8位  移到最高处
		wen=wen|temL;			   // 12.再跟低位相或   高八位和低八位就全部读取完成
		wen=wen*0.0625*10+0.5;	   // 13.把高八位和低八位的值通过计算得出实际的温度值。*0.0625 是温度的精度。 *100 是取后面2位小数点。 +0.5是四舍五入。
		return wen;				   // 14.放回值 等待下次运算
	                         /*注： 这里有两种计算办法  注：Keil2 不能计算小数点（wendu=wendu/16*10+wendu%16;）*/
}	