#include "STC51.h"
#include "intrins.h" 
#include "delay.h"
#include "DS18B20.h"
                      
void DS_18B20_init()		    //DS18B20 初始化
{	
		ds=1;			              //1.  先将数据线置高电平1;
		delayus(1);		          //2.  延时（该时间要求的不是很严格，但是尽可能的短一点）;
		ds=0;						        //3.  数据线拉到低电平0;
		delayus(490);				    //4.  延时490微秒（该时间的时间范围可以从480到960微秒);
		ds=1;						        //5.  先将数据线置高电平1;
		delayus(300);				    //6.  延时等待（如果初始化成功则在15到60毫秒时间之内产生一个由DS18B20所返回的低电平0。
											      //    直接跳过下面一些判断  延时代替  注：延时最少要150微秒  最大不能超过 500微秒                       
}
unsigned char DS_18B20_read()				  //读取温度函数   一位一位的取
{
		 unsigned char read;
		 ds=0;						     // 1. 将数据线拉低“0”。
		 _nop_();					  
		 _nop_();					     // 2. 延时确定的时间为2(小于15)微秒。
		 _nop_();
		 _nop_();
		 ds=1;						     // 3. 将数据线拉高“1”，同时端口应为输入状态。
		 _nop_();
		 _nop_();
		 _nop_();					     // 4. 延时确定的时间为4(小于15)微秒。
		 _nop_();
		 read=ds;						   // 5. 读数据线的状态得到1个状态位，并进行数据处理。
		 delayus(30);	         //  每次读完数据   必须要延时30~60微秒  再把中线拉高    否则读回数据是不对
		 ds=1;						     // 6. 总线拉高
		 delayus(2);				   // 7. 延时等待稳定
		 return read;					 // 8. 返回值  等待下次再读取
}
unsigned char DS_18B20_byte()	 //读取到的值写成一个字节函数
{
		unsigned char i,j,k;
		for(i=0;i<8;i++)			       //八位  一个字节有八位
		{
				j=DS_18B20_read();		   //先把读取的一位值送给变量存起来
				k=(j<<7)|(k>>1);		     //再把刚才读到哪个位向左移7位送给另一个变量存起来  
		}							      
		return k;					           //一次只能读一位，读完8次 返回值  等待下次读
	/********************************************************************************************
	比如：假设读回第一个值是‘1’  j=0000 0001 向左移7位变成  j=1000 0000
	运算：k默认的值是 0000 0000，k向右移一位，k=0000 0000， k=(j<<7)|(k>>1)   结果等于 k=1000 0000 
	到第二次读回的值是‘0’，j=0000 0000 向左移7位变成  j=0000 0000  。
	运算：k的值是 1000 0000 , k向右移一位 ， k=0100 0000， k=(j<<7)|(k>>1)    结果等于 k=0100 0000 
	***********************************************************************************************/
}
void DS_18B20_command(unsigned char command)
{
		unsigned char i;
		for(i=0;i<8;i++)
		{
				 ds=0;					         // 1. 数据线先置低电平0。
				 _nop_();				         // 2. 延时确定的时间为2(小于15)微秒。
				 _nop_();
				 _nop_();
				 _nop_();
				 ds=command&0x01; 		   // 3. 按从低位到高位的顺序发送字节（一次只发送一位）。
				 delayus(30);	           // 4. 每次送完数据和指令，必须要延时40~90微秒，再拉总线，否则写的指令是不对，对于STC单片机 这里要30us
				 ds=1;					         // 5. 将数据线拉到高电平
				 _nop_();
				 _nop_();				         // 6. 延时确定的时间为2(小于15)微秒。
				 _nop_();				   
				 command=command>>1;		 // 7. 把已经送完那位向右移除去
		}
		delayus(10);				         // 8. 送完8位后延时灯稳定
}
unsigned int DS_18B20_Get_Temp()			   //温度采集，运算
{
		unsigned char temH,temL;
		unsigned int Temp;
		DS_18B20_init();			         // 1. 温度初始化
		DS_18B20_command(0xcc);		     // 2. 跳过读序号列号的操作
		DS_18B20_command(0x44);		     // 3. 启动温度转换
		delayus(100);				           // 4. 延时等待一会
		DS_18B20_init();			         // 5. 温度再次初始化
		DS_18B20_command(0xcc);		     // 6. 再跳过读序号列号的操作
		DS_18B20_command(0xbe);		     // 7. 读取温度寄存器等（共可读9个寄存器） 前两个就是温度  
		temL=DS_18B20_byte();		       // 8. 取低位值存起来
		temH=DS_18B20_byte();		       // 9. 取高位值存起来
		Temp=temH;					           // 10.把高位值赋给16位的变量存起来
		Temp=Temp<<8;				           // 11.再把高位向左移8位  移到最高处
		Temp=Temp|temL;			           // 12.再跟低位相或   高八位和低八位就全部读取完成
		Temp=Temp*0.0625*10+0.5;	     // 13.把高八位和低八位的值通过计算得出实际的温度值。*0.0625 是温度的精度。 *100 是取后面2位小数点。 +0.5是四舍五入。
		return Temp;				           // 14.放回值 等待下次运算
	                                 // 注： 这里有两种计算办法  注：Keil2 不能计算小数点（wendu=wendu/16*10+wendu%16;）
}	